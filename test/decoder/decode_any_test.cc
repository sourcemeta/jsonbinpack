#include "decode_utils.h"
#include <jsonbinpack/decoder/decoder.h>
#include <jsontoolkit/json.h>

#include <gtest/gtest.h>
#include <string>

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__null) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x17};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(nullptr)};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__false) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x07};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(false)};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__true) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x0f};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(true)};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__real_3_14) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x2f, 0xf4, 0x04, 0x02};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(3.14)};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__256) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x1f, 0x80, 0x02};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(256)};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__minus_257) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x27, 0x80, 0x02};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(-257)};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__255) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x05, 0xff};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(255)};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__minus_256) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x06, 0xff};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(-256)};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__0) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x0d};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(0)};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__minus_1) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x0e};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(-1)};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_space) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x11, 0x20};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(" ")};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_foo) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x21, 0x66, 0x6f, 0x6f};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from("foo")};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_30_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0xf9, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(std::string(30, 'x'))};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__shared_string_foo) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x21, 0x66, 0x6f, 0x6f, 0x20, 0x04, 0x20, 0x06};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result1{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON result2{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON result3{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected1{
      sourcemeta::jsontoolkit::from("foo")};
  const sourcemeta::jsontoolkit::JSON expected2{
      sourcemeta::jsontoolkit::from("foo")};
  const sourcemeta::jsontoolkit::JSON expected3{
      sourcemeta::jsontoolkit::from("foo")};
  EXPECT_EQ(result1, expected1);
  EXPECT_EQ(result2, expected2);
  EXPECT_EQ(result3, expected3);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_31_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x02, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(std::string(31, 'x'))};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_61_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0xf2, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(std::string(61, 'x'))};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_url) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x73, 0x6f, 0x75,
      0x6e, 0x64, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
      0x64, 0x61, 0x6e, 0x64, 0x79, 0x6d, 0x75, 0x73, 0x69, 0x63, 0x6e, 0x6c};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from("https://soundcloud.com/dandymusicnl")};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_128_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x3f, 0x00, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(std::string(128, 'x'))};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_130_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x3f, 0x02, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(std::string(130, 'x'))};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_256_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x47, 0x00, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(std::string(256, 'x'))};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_258_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x47, 0x02, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(std::string(258, 'x'))};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_512_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x4f, 0x00,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(std::string(512, 'x'))};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_513_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x4f, 0x01,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(std::string(513, 'x'))};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_1024_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x57, 0x00,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(std::string(1024, 'x'))};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_62_xs_non_shared) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x01, 0x01, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(std::string(62, 'x'))};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_63_xs_non_shared) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x01, 0x02, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  const sourcemeta::jsontoolkit::JSON expected{
      sourcemeta::jsontoolkit::from(std::string(63, 'x'))};
  EXPECT_EQ(result, expected);
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__foo_true_2000) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x24, 0x21, 0x66, 0x6f, 0x6f,
                               0x0f, 0x1f, 0xd0, 0x0f};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};

  EXPECT_TRUE(sourcemeta::jsontoolkit::is_array(result));
  EXPECT_EQ(sourcemeta::jsontoolkit::size(result), 3);
  using namespace sourcemeta::jsontoolkit;
  EXPECT_EQ(at(result, 0), from("foo"));
  EXPECT_EQ(at(result, 1), from(true));
  EXPECT_EQ(at(result, 2), from(2000));
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__array_30) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0xfc, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                               0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                               0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                               0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};

  EXPECT_TRUE(sourcemeta::jsontoolkit::is_array(result));
  EXPECT_EQ(sourcemeta::jsontoolkit::size(result), 30);
  using namespace sourcemeta::jsontoolkit;

  EXPECT_EQ(at(result, 0), from(true));
  EXPECT_EQ(at(result, 1), from(true));
  EXPECT_EQ(at(result, 2), from(true));
  EXPECT_EQ(at(result, 3), from(true));
  EXPECT_EQ(at(result, 4), from(true));
  EXPECT_EQ(at(result, 5), from(true));
  EXPECT_EQ(at(result, 6), from(true));
  EXPECT_EQ(at(result, 7), from(true));
  EXPECT_EQ(at(result, 8), from(true));
  EXPECT_EQ(at(result, 9), from(true));

  EXPECT_EQ(at(result, 10), from(true));
  EXPECT_EQ(at(result, 11), from(true));
  EXPECT_EQ(at(result, 12), from(true));
  EXPECT_EQ(at(result, 13), from(true));
  EXPECT_EQ(at(result, 14), from(true));
  EXPECT_EQ(at(result, 15), from(true));
  EXPECT_EQ(at(result, 16), from(true));
  EXPECT_EQ(at(result, 17), from(true));
  EXPECT_EQ(at(result, 18), from(true));
  EXPECT_EQ(at(result, 19), from(true));

  EXPECT_EQ(at(result, 20), from(true));
  EXPECT_EQ(at(result, 21), from(true));
  EXPECT_EQ(at(result, 22), from(true));
  EXPECT_EQ(at(result, 23), from(true));
  EXPECT_EQ(at(result, 24), from(true));
  EXPECT_EQ(at(result, 25), from(true));
  EXPECT_EQ(at(result, 26), from(true));
  EXPECT_EQ(at(result, 27), from(true));
  EXPECT_EQ(at(result, 28), from(true));
  EXPECT_EQ(at(result, 29), from(true));
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__array_31) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x04, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
      0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
      0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};

  EXPECT_TRUE(sourcemeta::jsontoolkit::is_array(result));
  EXPECT_EQ(sourcemeta::jsontoolkit::size(result), 31);
  using namespace sourcemeta::jsontoolkit;

  EXPECT_EQ(at(result, 0), from(true));
  EXPECT_EQ(at(result, 1), from(true));
  EXPECT_EQ(at(result, 2), from(true));
  EXPECT_EQ(at(result, 3), from(true));
  EXPECT_EQ(at(result, 4), from(true));
  EXPECT_EQ(at(result, 5), from(true));
  EXPECT_EQ(at(result, 6), from(true));
  EXPECT_EQ(at(result, 7), from(true));
  EXPECT_EQ(at(result, 8), from(true));
  EXPECT_EQ(at(result, 9), from(true));

  EXPECT_EQ(at(result, 10), from(true));
  EXPECT_EQ(at(result, 11), from(true));
  EXPECT_EQ(at(result, 12), from(true));
  EXPECT_EQ(at(result, 13), from(true));
  EXPECT_EQ(at(result, 14), from(true));
  EXPECT_EQ(at(result, 15), from(true));
  EXPECT_EQ(at(result, 16), from(true));
  EXPECT_EQ(at(result, 17), from(true));
  EXPECT_EQ(at(result, 18), from(true));
  EXPECT_EQ(at(result, 19), from(true));

  EXPECT_EQ(at(result, 20), from(true));
  EXPECT_EQ(at(result, 21), from(true));
  EXPECT_EQ(at(result, 22), from(true));
  EXPECT_EQ(at(result, 23), from(true));
  EXPECT_EQ(at(result, 24), from(true));
  EXPECT_EQ(at(result, 25), from(true));
  EXPECT_EQ(at(result, 26), from(true));
  EXPECT_EQ(at(result, 27), from(true));
  EXPECT_EQ(at(result, 28), from(true));
  EXPECT_EQ(at(result, 29), from(true));

  EXPECT_EQ(at(result, 30), from(true));
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__array_32) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x04, 0x01, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
      0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
      0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};

  EXPECT_TRUE(sourcemeta::jsontoolkit::is_array(result));
  EXPECT_EQ(sourcemeta::jsontoolkit::size(result), 32);
  using namespace sourcemeta::jsontoolkit;

  EXPECT_EQ(at(result, 0), from(true));
  EXPECT_EQ(at(result, 1), from(true));
  EXPECT_EQ(at(result, 2), from(true));
  EXPECT_EQ(at(result, 3), from(true));
  EXPECT_EQ(at(result, 4), from(true));
  EXPECT_EQ(at(result, 5), from(true));
  EXPECT_EQ(at(result, 6), from(true));
  EXPECT_EQ(at(result, 7), from(true));
  EXPECT_EQ(at(result, 8), from(true));
  EXPECT_EQ(at(result, 9), from(true));

  EXPECT_EQ(at(result, 10), from(true));
  EXPECT_EQ(at(result, 11), from(true));
  EXPECT_EQ(at(result, 12), from(true));
  EXPECT_EQ(at(result, 13), from(true));
  EXPECT_EQ(at(result, 14), from(true));
  EXPECT_EQ(at(result, 15), from(true));
  EXPECT_EQ(at(result, 16), from(true));
  EXPECT_EQ(at(result, 17), from(true));
  EXPECT_EQ(at(result, 18), from(true));
  EXPECT_EQ(at(result, 19), from(true));

  EXPECT_EQ(at(result, 20), from(true));
  EXPECT_EQ(at(result, 21), from(true));
  EXPECT_EQ(at(result, 22), from(true));
  EXPECT_EQ(at(result, 23), from(true));
  EXPECT_EQ(at(result, 24), from(true));
  EXPECT_EQ(at(result, 25), from(true));
  EXPECT_EQ(at(result, 26), from(true));
  EXPECT_EQ(at(result, 27), from(true));
  EXPECT_EQ(at(result, 28), from(true));
  EXPECT_EQ(at(result, 29), from(true));

  EXPECT_EQ(at(result, 30), from(true));
  EXPECT_EQ(at(result, 31), from(true));
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__object_foo_bar_baz_1) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{0x1b, 0x04, 0x66, 0x6f, 0x6f, 0x21, 0x62,
                               0x61, 0x72, 0x04, 0x62, 0x61, 0x7a, 0x15};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  EXPECT_TRUE(sourcemeta::jsontoolkit::is_object(result));
  EXPECT_EQ(sourcemeta::jsontoolkit::size(result), 2);

  EXPECT_TRUE(sourcemeta::jsontoolkit::defines(result, "foo"));
  const auto &foo{sourcemeta::jsontoolkit::at(result, "foo")};
  EXPECT_TRUE(sourcemeta::jsontoolkit::is_string(foo));
  EXPECT_EQ(sourcemeta::jsontoolkit::to_string(foo), "bar");

  EXPECT_TRUE(sourcemeta::jsontoolkit::defines(result, "baz"));
  const auto &baz{sourcemeta::jsontoolkit::at(result, "baz")};
  EXPECT_TRUE(sourcemeta::jsontoolkit::is_integer(baz));
  EXPECT_EQ(sourcemeta::jsontoolkit::to_integer(baz), 1);
}

static auto is_member_true(const sourcemeta::jsontoolkit::JSON &object,
                           const std::string &key) -> bool {
  return sourcemeta::jsontoolkit::defines(object, key) &&
         sourcemeta::jsontoolkit::is_boolean(
             sourcemeta::jsontoolkit::at(object, key)) &&
         sourcemeta::jsontoolkit::to_boolean(
             sourcemeta::jsontoolkit::at(object, key));
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__object_30_entries) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0xfb, 0x03, 0x30, 0x30, 0x0f, 0x03, 0x30, 0x31, 0x0f, 0x03, 0x30,
      0x32, 0x0f, 0x03, 0x30, 0x33, 0x0f, 0x03, 0x30, 0x34, 0x0f, 0x03,
      0x30, 0x35, 0x0f, 0x03, 0x30, 0x36, 0x0f, 0x03, 0x30, 0x37, 0x0f,
      0x03, 0x30, 0x38, 0x0f, 0x03, 0x30, 0x39, 0x0f, 0x03, 0x31, 0x30,
      0x0f, 0x03, 0x31, 0x31, 0x0f, 0x03, 0x31, 0x32, 0x0f, 0x03, 0x31,
      0x33, 0x0f, 0x03, 0x31, 0x34, 0x0f, 0x03, 0x31, 0x35, 0x0f, 0x03,
      0x31, 0x36, 0x0f, 0x03, 0x31, 0x37, 0x0f, 0x03, 0x31, 0x38, 0x0f,
      0x03, 0x31, 0x39, 0x0f, 0x03, 0x32, 0x30, 0x0f, 0x03, 0x32, 0x31,
      0x0f, 0x03, 0x32, 0x32, 0x0f, 0x03, 0x32, 0x33, 0x0f, 0x03, 0x32,
      0x34, 0x0f, 0x03, 0x32, 0x35, 0x0f, 0x03, 0x32, 0x36, 0x0f, 0x03,
      0x32, 0x37, 0x0f, 0x03, 0x32, 0x38, 0x0f, 0x03, 0x32, 0x39, 0x0f};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  EXPECT_TRUE(sourcemeta::jsontoolkit::is_object(result));
  EXPECT_EQ(sourcemeta::jsontoolkit::size(result), 30);

  EXPECT_TRUE(is_member_true(result, "00"));
  EXPECT_TRUE(is_member_true(result, "01"));
  EXPECT_TRUE(is_member_true(result, "02"));
  EXPECT_TRUE(is_member_true(result, "03"));
  EXPECT_TRUE(is_member_true(result, "04"));
  EXPECT_TRUE(is_member_true(result, "05"));
  EXPECT_TRUE(is_member_true(result, "06"));
  EXPECT_TRUE(is_member_true(result, "07"));
  EXPECT_TRUE(is_member_true(result, "08"));
  EXPECT_TRUE(is_member_true(result, "09"));

  EXPECT_TRUE(is_member_true(result, "10"));
  EXPECT_TRUE(is_member_true(result, "11"));
  EXPECT_TRUE(is_member_true(result, "12"));
  EXPECT_TRUE(is_member_true(result, "13"));
  EXPECT_TRUE(is_member_true(result, "14"));
  EXPECT_TRUE(is_member_true(result, "15"));
  EXPECT_TRUE(is_member_true(result, "16"));
  EXPECT_TRUE(is_member_true(result, "17"));
  EXPECT_TRUE(is_member_true(result, "18"));
  EXPECT_TRUE(is_member_true(result, "19"));

  EXPECT_TRUE(is_member_true(result, "20"));
  EXPECT_TRUE(is_member_true(result, "21"));
  EXPECT_TRUE(is_member_true(result, "22"));
  EXPECT_TRUE(is_member_true(result, "23"));
  EXPECT_TRUE(is_member_true(result, "24"));
  EXPECT_TRUE(is_member_true(result, "25"));
  EXPECT_TRUE(is_member_true(result, "26"));
  EXPECT_TRUE(is_member_true(result, "27"));
  EXPECT_TRUE(is_member_true(result, "28"));
  EXPECT_TRUE(is_member_true(result, "29"));
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__object_31_entries) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x03, 0x00, 0x03, 0x30, 0x30, 0x0f, 0x03, 0x30, 0x31, 0x0f, 0x03, 0x30,
      0x32, 0x0f, 0x03, 0x30, 0x33, 0x0f, 0x03, 0x30, 0x34, 0x0f, 0x03, 0x30,
      0x35, 0x0f, 0x03, 0x30, 0x36, 0x0f, 0x03, 0x30, 0x37, 0x0f, 0x03, 0x30,
      0x38, 0x0f, 0x03, 0x30, 0x39, 0x0f, 0x03, 0x31, 0x30, 0x0f, 0x03, 0x31,
      0x31, 0x0f, 0x03, 0x31, 0x32, 0x0f, 0x03, 0x31, 0x33, 0x0f, 0x03, 0x31,
      0x34, 0x0f, 0x03, 0x31, 0x35, 0x0f, 0x03, 0x31, 0x36, 0x0f, 0x03, 0x31,
      0x37, 0x0f, 0x03, 0x31, 0x38, 0x0f, 0x03, 0x31, 0x39, 0x0f, 0x03, 0x32,
      0x30, 0x0f, 0x03, 0x32, 0x31, 0x0f, 0x03, 0x32, 0x32, 0x0f, 0x03, 0x32,
      0x33, 0x0f, 0x03, 0x32, 0x34, 0x0f, 0x03, 0x32, 0x35, 0x0f, 0x03, 0x32,
      0x36, 0x0f, 0x03, 0x32, 0x37, 0x0f, 0x03, 0x32, 0x38, 0x0f, 0x03, 0x32,
      0x39, 0x0f, 0x03, 0x33, 0x30, 0x0f};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  EXPECT_TRUE(sourcemeta::jsontoolkit::is_object(result));
  EXPECT_EQ(sourcemeta::jsontoolkit::size(result), 31);

  EXPECT_TRUE(is_member_true(result, "00"));
  EXPECT_TRUE(is_member_true(result, "01"));
  EXPECT_TRUE(is_member_true(result, "02"));
  EXPECT_TRUE(is_member_true(result, "03"));
  EXPECT_TRUE(is_member_true(result, "04"));
  EXPECT_TRUE(is_member_true(result, "05"));
  EXPECT_TRUE(is_member_true(result, "06"));
  EXPECT_TRUE(is_member_true(result, "07"));
  EXPECT_TRUE(is_member_true(result, "08"));
  EXPECT_TRUE(is_member_true(result, "09"));

  EXPECT_TRUE(is_member_true(result, "10"));
  EXPECT_TRUE(is_member_true(result, "11"));
  EXPECT_TRUE(is_member_true(result, "12"));
  EXPECT_TRUE(is_member_true(result, "13"));
  EXPECT_TRUE(is_member_true(result, "14"));
  EXPECT_TRUE(is_member_true(result, "15"));
  EXPECT_TRUE(is_member_true(result, "16"));
  EXPECT_TRUE(is_member_true(result, "17"));
  EXPECT_TRUE(is_member_true(result, "18"));
  EXPECT_TRUE(is_member_true(result, "19"));

  EXPECT_TRUE(is_member_true(result, "20"));
  EXPECT_TRUE(is_member_true(result, "21"));
  EXPECT_TRUE(is_member_true(result, "22"));
  EXPECT_TRUE(is_member_true(result, "23"));
  EXPECT_TRUE(is_member_true(result, "24"));
  EXPECT_TRUE(is_member_true(result, "25"));
  EXPECT_TRUE(is_member_true(result, "26"));
  EXPECT_TRUE(is_member_true(result, "27"));
  EXPECT_TRUE(is_member_true(result, "28"));
  EXPECT_TRUE(is_member_true(result, "29"));

  EXPECT_TRUE(is_member_true(result, "30"));
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__object_32_entries) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x03, 0x01, 0x03, 0x30, 0x30, 0x0f, 0x03, 0x30, 0x31, 0x0f, 0x03, 0x30,
      0x32, 0x0f, 0x03, 0x30, 0x33, 0x0f, 0x03, 0x30, 0x34, 0x0f, 0x03, 0x30,
      0x35, 0x0f, 0x03, 0x30, 0x36, 0x0f, 0x03, 0x30, 0x37, 0x0f, 0x03, 0x30,
      0x38, 0x0f, 0x03, 0x30, 0x39, 0x0f, 0x03, 0x31, 0x30, 0x0f, 0x03, 0x31,
      0x31, 0x0f, 0x03, 0x31, 0x32, 0x0f, 0x03, 0x31, 0x33, 0x0f, 0x03, 0x31,
      0x34, 0x0f, 0x03, 0x31, 0x35, 0x0f, 0x03, 0x31, 0x36, 0x0f, 0x03, 0x31,
      0x37, 0x0f, 0x03, 0x31, 0x38, 0x0f, 0x03, 0x31, 0x39, 0x0f, 0x03, 0x32,
      0x30, 0x0f, 0x03, 0x32, 0x31, 0x0f, 0x03, 0x32, 0x32, 0x0f, 0x03, 0x32,
      0x33, 0x0f, 0x03, 0x32, 0x34, 0x0f, 0x03, 0x32, 0x35, 0x0f, 0x03, 0x32,
      0x36, 0x0f, 0x03, 0x32, 0x37, 0x0f, 0x03, 0x32, 0x38, 0x0f, 0x03, 0x32,
      0x39, 0x0f, 0x03, 0x33, 0x30, 0x0f, 0x03, 0x33, 0x31, 0x0f};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  EXPECT_TRUE(sourcemeta::jsontoolkit::is_object(result));
  EXPECT_EQ(sourcemeta::jsontoolkit::size(result), 32);

  EXPECT_TRUE(is_member_true(result, "00"));
  EXPECT_TRUE(is_member_true(result, "01"));
  EXPECT_TRUE(is_member_true(result, "02"));
  EXPECT_TRUE(is_member_true(result, "03"));
  EXPECT_TRUE(is_member_true(result, "04"));
  EXPECT_TRUE(is_member_true(result, "05"));
  EXPECT_TRUE(is_member_true(result, "06"));
  EXPECT_TRUE(is_member_true(result, "07"));
  EXPECT_TRUE(is_member_true(result, "08"));
  EXPECT_TRUE(is_member_true(result, "09"));

  EXPECT_TRUE(is_member_true(result, "10"));
  EXPECT_TRUE(is_member_true(result, "11"));
  EXPECT_TRUE(is_member_true(result, "12"));
  EXPECT_TRUE(is_member_true(result, "13"));
  EXPECT_TRUE(is_member_true(result, "14"));
  EXPECT_TRUE(is_member_true(result, "15"));
  EXPECT_TRUE(is_member_true(result, "16"));
  EXPECT_TRUE(is_member_true(result, "17"));
  EXPECT_TRUE(is_member_true(result, "18"));
  EXPECT_TRUE(is_member_true(result, "19"));

  EXPECT_TRUE(is_member_true(result, "20"));
  EXPECT_TRUE(is_member_true(result, "21"));
  EXPECT_TRUE(is_member_true(result, "22"));
  EXPECT_TRUE(is_member_true(result, "23"));
  EXPECT_TRUE(is_member_true(result, "24"));
  EXPECT_TRUE(is_member_true(result, "25"));
  EXPECT_TRUE(is_member_true(result, "26"));
  EXPECT_TRUE(is_member_true(result, "27"));
  EXPECT_TRUE(is_member_true(result, "28"));
  EXPECT_TRUE(is_member_true(result, "29"));

  EXPECT_TRUE(is_member_true(result, "30"));
  EXPECT_TRUE(is_member_true(result, "31"));
}

TEST(Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__object_62_xs_shared) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream<char> stream{
      0x1b, 0x04, 0x66, 0x6f, 0x6f, 0x01, 0x01, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x04, 0x62, 0x61, 0x72, 0x00, 0x01, 0x44};
  Decoder decoder{stream};
  const sourcemeta::jsontoolkit::JSON result{
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({})};
  EXPECT_TRUE(sourcemeta::jsontoolkit::is_object(result));
  EXPECT_EQ(sourcemeta::jsontoolkit::size(result), 2);

  EXPECT_TRUE(sourcemeta::jsontoolkit::defines(result, "foo"));
  const auto &foo{sourcemeta::jsontoolkit::at(result, "foo")};
  EXPECT_TRUE(sourcemeta::jsontoolkit::is_string(foo));
  EXPECT_EQ(sourcemeta::jsontoolkit::to_string(foo), std::string(62, 'x'));

  EXPECT_TRUE(sourcemeta::jsontoolkit::defines(result, "bar"));
  const auto &baz{sourcemeta::jsontoolkit::at(result, "bar")};
  EXPECT_TRUE(sourcemeta::jsontoolkit::is_string(baz));
  EXPECT_EQ(sourcemeta::jsontoolkit::to_string(baz), std::string(62, 'x'));
}
