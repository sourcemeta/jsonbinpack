#include "encode_utils.h"
#include <jsonbinpack/encoder/encoder.h>
#include <jsontoolkit/json.h>

#include <gtest/gtest.h>
#include <string>

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__null) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from(nullptr)};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {0x17});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__false) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::from(false)};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {0x07});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__true) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::from(true)};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {0x0f});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__real_3_14) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::from(3.14)};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {
                           0x2f,            // tag: real number
                           0xf4, 0x04, 0x02 // 3.14
                       });
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__256) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::from(256)};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {
                           0x1f,      // tag: positive varint
                           0x80, 0x02 // 256
                       });
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__minus_257) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::from(-257)};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {
                           0x27,      // tag: negative varint
                           0x80, 0x02 // 256 = abs(-257) - 1
                       });
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__255) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::from(255)};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {
                           0x05, // tag: positive byte
                           0xff  // 255
                       });
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__minus_256) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::from(-256)};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {
                           0x06, // tag: negative byte
                           0xff  // 255 = abs(-256) - 1
                       });
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__0) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::from(0)};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {0x0d});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__minus_1) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::from(-1)};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {0x0e});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_space) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::from(" ")};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {0x11, 0x20});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_foo) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::from("foo")};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {0x21, 0x66, 0x6f, 0x6f});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_30_xs) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from(std::string(30, 'x'))};
  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 30);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {0xf9, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                        0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                        0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                        0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__shared_string_foo) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::from("foo")};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {
                           0x21,             // tag: string with length 3
                           0x66, 0x6f, 0x6f, // "foo"
                           0x20,             // tag: shared string with length 3
                           0x04,             // position (5) - offset (1) = 4
                           0x20,             // tag: shared string with length 3
                           0x06              // position (7) - offset (1) = 6
                       });
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_31_xs) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from(std::string(31, 'x'))};
  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 31);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {0x02, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                        0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                        0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                        0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_61_xs) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from(std::string(61, 'x'))};
  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 61);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {0xf2, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                        0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                        0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                        0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                        0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                        0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                        0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_url) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from("https://soundcloud.com/dandymusicnl")};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f,
                        0x73, 0x6f, 0x75, 0x6e, 0x64, 0x63, 0x6c, 0x6f, 0x75,
                        0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x64, 0x61, 0x6e,
                        0x64, 0x79, 0x6d, 0x75, 0x73, 0x69, 0x63, 0x6e, 0x6c});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_128_xs) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from(std::string(128, 'x'))};
  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 128);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(
      stream,
      {0x3f, // tag: long string, minimum 2^7
       0x00, // length - 2^7
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_130_xs) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from(std::string(130, 'x'))};
  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 130);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(
      stream,
      {0x3f, // tag: long string, minimum 2^7
       0x02, // length - 2^7
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_256_xs) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from(std::string(256, 'x'))};
  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 256);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(
      stream,
      {0x47, // tag: long string, minimum 2^8
       0x00, // length - 2^8
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_258_xs) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from(std::string(258, 'x'))};
  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 258);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(
      stream,
      {0x47, // tag: long string, minimum 2^8
       0x02, // length - 2^8
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_512_xs) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from(std::string(512, 'x'))};
  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 512);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(
      stream,
      {0x4f, // tag: long string, minimum 2^9
       0x00, // length - 2^9

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_513_xs) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from(std::string(513, 'x'))};
  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 513);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(
      stream,
      {0x4f, // tag: long string, minimum 2^9
       0x01, // length - 2^9

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_1024_xs) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from(std::string(1024, 'x'))};
  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 1024);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(
      stream,
      {0x57, // tag: long string, minimum 2^10
       0x00, // length - 2^10

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78,

       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
       0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_62_xs_non_shared) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from(std::string(62, 'x'))};
  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 62);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(
      stream, {0x01, 0x01, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_63_xs_non_shared) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::from(std::string(63, 'x'))};
  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 63);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(
      stream, {0x01, 0x02, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
               0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__foo_true_2000) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::parse("[ \"foo\", true, 2000 ]")};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {
                           0x24,                   // tag: array with length 3
                           0x21, 0x66, 0x6f, 0x6f, // "foo"
                           0x0f,                   // true
                           0x1f, 0xd0, 0x0f        // 2000
                       });
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__array_30) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::make_array()};
  for (auto count = 0; count < 30; count++) {
    sourcemeta::jsontoolkit::push_back(document,
                                       sourcemeta::jsontoolkit::from(true));
  }

  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 30);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream,
               {0xfc, // tag: array with length 30
                0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__array_31) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{sourcemeta::jsontoolkit::make_array()};
  for (auto count = 0; count < 31; count++) {
    sourcemeta::jsontoolkit::push_back(document,
                                       sourcemeta::jsontoolkit::from(true));
  }

  EXPECT_EQ(sourcemeta::jsontoolkit::size(document), 31);
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream,
               {0x04, // tag: array
                0x1f, // length 31
                0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f});
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__object_foo_bar_baz_1) {
  using namespace sourcemeta::jsonbinpack;
  const sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::parse("{ \"foo\": \"bar\", \"baz\": 1 }")};
  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream,
               {
                   0x1b,                   // tag: object (with length 2)
                   0x04, 0x66, 0x6f, 0x6f, // String length 3 + "foo"
                   0x21, 0x62, 0x61, 0x72, // String tag + length + 'bar'
                   0x04, 0x62, 0x61, 0x7a, // String length 3 + 'baz'
                   0x15                    // Positive integer tag with value 1
               });
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__object_30_entries) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::make_object()};
  const sourcemeta::jsontoolkit::JSON value{
      sourcemeta::jsontoolkit::from(true)};

  sourcemeta::jsontoolkit::assign(document, "00", value);
  sourcemeta::jsontoolkit::assign(document, "01", value);
  sourcemeta::jsontoolkit::assign(document, "02", value);
  sourcemeta::jsontoolkit::assign(document, "03", value);
  sourcemeta::jsontoolkit::assign(document, "04", value);
  sourcemeta::jsontoolkit::assign(document, "05", value);
  sourcemeta::jsontoolkit::assign(document, "06", value);
  sourcemeta::jsontoolkit::assign(document, "07", value);
  sourcemeta::jsontoolkit::assign(document, "08", value);
  sourcemeta::jsontoolkit::assign(document, "09", value);

  sourcemeta::jsontoolkit::assign(document, "10", value);
  sourcemeta::jsontoolkit::assign(document, "11", value);
  sourcemeta::jsontoolkit::assign(document, "12", value);
  sourcemeta::jsontoolkit::assign(document, "13", value);
  sourcemeta::jsontoolkit::assign(document, "14", value);
  sourcemeta::jsontoolkit::assign(document, "15", value);
  sourcemeta::jsontoolkit::assign(document, "16", value);
  sourcemeta::jsontoolkit::assign(document, "17", value);
  sourcemeta::jsontoolkit::assign(document, "18", value);
  sourcemeta::jsontoolkit::assign(document, "19", value);

  sourcemeta::jsontoolkit::assign(document, "20", value);
  sourcemeta::jsontoolkit::assign(document, "21", value);
  sourcemeta::jsontoolkit::assign(document, "22", value);
  sourcemeta::jsontoolkit::assign(document, "23", value);
  sourcemeta::jsontoolkit::assign(document, "24", value);
  sourcemeta::jsontoolkit::assign(document, "25", value);
  sourcemeta::jsontoolkit::assign(document, "26", value);
  sourcemeta::jsontoolkit::assign(document, "27", value);
  sourcemeta::jsontoolkit::assign(document, "28", value);
  sourcemeta::jsontoolkit::assign(document, "29", value);

  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {
                           0xfb, // Object with size 30

                           0x03, 0x30, 0x30, 0x0f, // Key "00" = true
                           0x03, 0x30, 0x31, 0x0f, // Key "01" = true
                           0x03, 0x30, 0x32, 0x0f, // Key "02" = true
                           0x03, 0x30, 0x33, 0x0f, // Key "03" = true
                           0x03, 0x30, 0x34, 0x0f, // Key "04" = true
                           0x03, 0x30, 0x35, 0x0f, // Key "05" = true
                           0x03, 0x30, 0x36, 0x0f, // Key "06" = true
                           0x03, 0x30, 0x37, 0x0f, // Key "07" = true
                           0x03, 0x30, 0x38, 0x0f, // Key "08" = true
                           0x03, 0x30, 0x39, 0x0f, // Key "09" = true

                           0x03, 0x31, 0x30, 0x0f, // Key "10" = true
                           0x03, 0x31, 0x31, 0x0f, // Key "11" = true
                           0x03, 0x31, 0x32, 0x0f, // Key "12" = true
                           0x03, 0x31, 0x33, 0x0f, // Key "13" = true
                           0x03, 0x31, 0x34, 0x0f, // Key "14" = true
                           0x03, 0x31, 0x35, 0x0f, // Key "15" = true
                           0x03, 0x31, 0x36, 0x0f, // Key "16" = true
                           0x03, 0x31, 0x37, 0x0f, // Key "17" = true
                           0x03, 0x31, 0x38, 0x0f, // Key "18" = true
                           0x03, 0x31, 0x39, 0x0f, // Key "19" = true

                           0x03, 0x32, 0x30, 0x0f, // Key "20" = true
                           0x03, 0x32, 0x31, 0x0f, // Key "21" = true
                           0x03, 0x32, 0x32, 0x0f, // Key "22" = true
                           0x03, 0x32, 0x33, 0x0f, // Key "23" = true
                           0x03, 0x32, 0x34, 0x0f, // Key "24" = true
                           0x03, 0x32, 0x35, 0x0f, // Key "25" = true
                           0x03, 0x32, 0x36, 0x0f, // Key "26" = true
                           0x03, 0x32, 0x37, 0x0f, // Key "27" = true
                           0x03, 0x32, 0x38, 0x0f, // Key "28" = true
                           0x03, 0x32, 0x39, 0x0f  // Key "29" = true
                       });
}

TEST(Encoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__object_31_entries) {
  using namespace sourcemeta::jsonbinpack;
  sourcemeta::jsontoolkit::JSON document{
      sourcemeta::jsontoolkit::make_object()};
  const sourcemeta::jsontoolkit::JSON value{
      sourcemeta::jsontoolkit::from(true)};

  sourcemeta::jsontoolkit::assign(document, "00", value);
  sourcemeta::jsontoolkit::assign(document, "01", value);
  sourcemeta::jsontoolkit::assign(document, "02", value);
  sourcemeta::jsontoolkit::assign(document, "03", value);
  sourcemeta::jsontoolkit::assign(document, "04", value);
  sourcemeta::jsontoolkit::assign(document, "05", value);
  sourcemeta::jsontoolkit::assign(document, "06", value);
  sourcemeta::jsontoolkit::assign(document, "07", value);
  sourcemeta::jsontoolkit::assign(document, "08", value);
  sourcemeta::jsontoolkit::assign(document, "09", value);

  sourcemeta::jsontoolkit::assign(document, "10", value);
  sourcemeta::jsontoolkit::assign(document, "11", value);
  sourcemeta::jsontoolkit::assign(document, "12", value);
  sourcemeta::jsontoolkit::assign(document, "13", value);
  sourcemeta::jsontoolkit::assign(document, "14", value);
  sourcemeta::jsontoolkit::assign(document, "15", value);
  sourcemeta::jsontoolkit::assign(document, "16", value);
  sourcemeta::jsontoolkit::assign(document, "17", value);
  sourcemeta::jsontoolkit::assign(document, "18", value);
  sourcemeta::jsontoolkit::assign(document, "19", value);

  sourcemeta::jsontoolkit::assign(document, "20", value);
  sourcemeta::jsontoolkit::assign(document, "21", value);
  sourcemeta::jsontoolkit::assign(document, "22", value);
  sourcemeta::jsontoolkit::assign(document, "23", value);
  sourcemeta::jsontoolkit::assign(document, "24", value);
  sourcemeta::jsontoolkit::assign(document, "25", value);
  sourcemeta::jsontoolkit::assign(document, "26", value);
  sourcemeta::jsontoolkit::assign(document, "27", value);
  sourcemeta::jsontoolkit::assign(document, "28", value);
  sourcemeta::jsontoolkit::assign(document, "29", value);

  sourcemeta::jsontoolkit::assign(document, "30", value);

  OutputByteStream<char> stream{};

  Encoder encoder{stream};
  encoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX(document, {});
  EXPECT_BYTES(stream, {
                           0x03, // tag: object
                           0x1f, // length 31

                           0x03, 0x30, 0x30, 0x0f, // Key "00" = true
                           0x03, 0x30, 0x31, 0x0f, // Key "01" = true
                           0x03, 0x30, 0x32, 0x0f, // Key "02" = true
                           0x03, 0x30, 0x33, 0x0f, // Key "03" = true
                           0x03, 0x30, 0x34, 0x0f, // Key "04" = true
                           0x03, 0x30, 0x35, 0x0f, // Key "05" = true
                           0x03, 0x30, 0x36, 0x0f, // Key "06" = true
                           0x03, 0x30, 0x37, 0x0f, // Key "07" = true
                           0x03, 0x30, 0x38, 0x0f, // Key "08" = true
                           0x03, 0x30, 0x39, 0x0f, // Key "09" = true

                           0x03, 0x31, 0x30, 0x0f, // Key "10" = true
                           0x03, 0x31, 0x31, 0x0f, // Key "11" = true
                           0x03, 0x31, 0x32, 0x0f, // Key "12" = true
                           0x03, 0x31, 0x33, 0x0f, // Key "13" = true
                           0x03, 0x31, 0x34, 0x0f, // Key "14" = true
                           0x03, 0x31, 0x35, 0x0f, // Key "15" = true
                           0x03, 0x31, 0x36, 0x0f, // Key "16" = true
                           0x03, 0x31, 0x37, 0x0f, // Key "17" = true
                           0x03, 0x31, 0x38, 0x0f, // Key "18" = true
                           0x03, 0x31, 0x39, 0x0f, // Key "19" = true

                           0x03, 0x32, 0x30, 0x0f, // Key "20" = true
                           0x03, 0x32, 0x31, 0x0f, // Key "21" = true
                           0x03, 0x32, 0x32, 0x0f, // Key "22" = true
                           0x03, 0x32, 0x33, 0x0f, // Key "23" = true
                           0x03, 0x32, 0x34, 0x0f, // Key "24" = true
                           0x03, 0x32, 0x35, 0x0f, // Key "25" = true
                           0x03, 0x32, 0x36, 0x0f, // Key "26" = true
                           0x03, 0x32, 0x37, 0x0f, // Key "27" = true
                           0x03, 0x32, 0x38, 0x0f, // Key "28" = true
                           0x03, 0x32, 0x39, 0x0f, // Key "29" = true

                           0x03, 0x33, 0x30, 0x0f // Key "30" = true
                       });
}
