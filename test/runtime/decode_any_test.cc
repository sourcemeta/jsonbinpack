#include <gtest/gtest.h>

#include "decode_utils.h"

#include <sourcemeta/core/json.h>
#include <sourcemeta/jsonbinpack/runtime.h>

#include <string>
#include <utility>
#include <vector>

TEST(JSONBinPack_Decoder, BYTE_CHOICE_INDEX_1__1_0_0) {
  InputByteStream stream{0x00};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.emplace_back(1);
  choices.emplace_back(0);
  choices.emplace_back(0);
  const auto result = decoder.BYTE_CHOICE_INDEX({std::move(choices)});
  const sourcemeta::core::JSON expected{1};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, BYTE_CHOICE_INDEX_1__0_1_0) {
  InputByteStream stream{0x01};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.emplace_back(0);
  choices.emplace_back(1);
  choices.emplace_back(0);
  const auto result = decoder.BYTE_CHOICE_INDEX({std::move(choices)});
  const sourcemeta::core::JSON expected{1};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, BYTE_CHOICE_INDEX_1__0_0_1) {
  InputByteStream stream{0x02};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.emplace_back(0);
  choices.emplace_back(0);
  choices.emplace_back(1);
  const auto result = decoder.BYTE_CHOICE_INDEX({std::move(choices)});
  const sourcemeta::core::JSON expected{1};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, BYTE_CHOICE_INDEX_bar__foo_bar_bar) {
  InputByteStream stream{0x01};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.emplace_back("foo");
  choices.emplace_back("bar");
  choices.emplace_back("bar");
  const auto result = decoder.BYTE_CHOICE_INDEX({std::move(choices)});
  const sourcemeta::core::JSON expected{"bar"};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, BYTE_CHOICE_INDEX_non_scalar_1) {
  InputByteStream stream{0x03};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.push_back(sourcemeta::core::parse_json("{ \"foo\": 2 }"));
  choices.push_back(sourcemeta::core::parse_json("{}"));
  choices.push_back(sourcemeta::core::parse_json("[ 1, 2, 3 ]"));
  choices.push_back(sourcemeta::core::parse_json("{ \"foo\": 1 }"));
  choices.push_back(sourcemeta::core::parse_json("{ \"bar\": 1 }"));
  const auto result = decoder.BYTE_CHOICE_INDEX({std::move(choices)});
  const auto expected = sourcemeta::core::parse_json("{ \"foo\": 1 }");
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, LARGE_CHOICE_INDEX_1__1_0_0) {
  InputByteStream stream{0x00};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.emplace_back(1);
  choices.emplace_back(0);
  choices.emplace_back(0);
  const auto result = decoder.LARGE_CHOICE_INDEX({std::move(choices)});
  const sourcemeta::core::JSON expected{1};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, LARGE_CHOICE_INDEX_1__0_1_0) {
  InputByteStream stream{0x01};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.emplace_back(0);
  choices.emplace_back(1);
  choices.emplace_back(0);
  const auto result = decoder.LARGE_CHOICE_INDEX({std::move(choices)});
  const sourcemeta::core::JSON expected{1};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, LARGE_CHOICE_INDEX_1__0_0_1) {
  InputByteStream stream{0x02};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.emplace_back(0);
  choices.emplace_back(0);
  choices.emplace_back(1);
  const auto result = decoder.LARGE_CHOICE_INDEX({std::move(choices)});
  const sourcemeta::core::JSON expected{1};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, LARGE_CHOICE_INDEX_bar__foo_bar_bar) {
  InputByteStream stream{0x01};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.emplace_back("foo");
  choices.emplace_back("bar");
  choices.emplace_back("bar");
  const auto result = decoder.LARGE_CHOICE_INDEX({std::move(choices)});
  const sourcemeta::core::JSON expected{"bar"};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, LARGE_CHOICE_INDEX_non_scalar_1) {
  InputByteStream stream{0x03};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.push_back(sourcemeta::core::parse_json("{ \"foo\": 2 }"));
  choices.push_back(sourcemeta::core::parse_json("{}"));
  choices.push_back(sourcemeta::core::parse_json("[ 1, 2, 3 ]"));
  choices.push_back(sourcemeta::core::parse_json("{ \"foo\": 1 }"));
  choices.push_back(sourcemeta::core::parse_json("{ \"bar\": 1 }"));
  const auto result = decoder.LARGE_CHOICE_INDEX({std::move(choices)});
  const auto expected = sourcemeta::core::parse_json("{ \"foo\": 1 }");
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, LARGE_CHOICE_INDEX_enum_250) {
  InputByteStream stream{0xfa, 0x01};
  sourcemeta::jsonbinpack::Decoder decoder{stream};

  std::vector<sourcemeta::core::JSON> choices;
  for (std::int64_t x = 0; x < 255; x++) {
    choices.emplace_back(x);
  }

  const auto result = decoder.LARGE_CHOICE_INDEX({std::move(choices)});
  const sourcemeta::core::JSON expected{250};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, TOP_LEVEL_BYTE_CHOICE_INDEX_1__1_0_0) {
  InputByteStream stream{};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.emplace_back(1);
  choices.emplace_back(0);
  choices.emplace_back(0);
  const auto result = decoder.TOP_LEVEL_BYTE_CHOICE_INDEX({std::move(choices)});
  const sourcemeta::core::JSON expected{1};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, TOP_LEVEL_BYTE_CHOICE_INDEX_1__0_1_0) {
  InputByteStream stream{0x00};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.emplace_back(0);
  choices.emplace_back(1);
  choices.emplace_back(0);
  const auto result = decoder.TOP_LEVEL_BYTE_CHOICE_INDEX({std::move(choices)});
  const sourcemeta::core::JSON expected{1};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, TOP_LEVEL_BYTE_CHOICE_INDEX_1__0_0_1) {
  InputByteStream stream{0x01};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.emplace_back(0);
  choices.emplace_back(0);
  choices.emplace_back(1);
  const auto result = decoder.TOP_LEVEL_BYTE_CHOICE_INDEX({std::move(choices)});
  const sourcemeta::core::JSON expected{1};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, TOP_LEVEL_BYTE_CHOICE_INDEX_bar__foo_bar_bar) {
  InputByteStream stream{0x00};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.emplace_back("foo");
  choices.emplace_back("bar");
  choices.emplace_back("bar");
  const auto result = decoder.TOP_LEVEL_BYTE_CHOICE_INDEX({std::move(choices)});
  const sourcemeta::core::JSON expected{"bar"};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, TOP_LEVEL_BYTE_CHOICE_INDEX_non_scalar_1) {
  InputByteStream stream{0x02};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  std::vector<sourcemeta::core::JSON> choices;
  choices.push_back(sourcemeta::core::parse_json("{ \"foo\": 2 }"));
  choices.push_back(sourcemeta::core::parse_json("{}"));
  choices.push_back(sourcemeta::core::parse_json("[ 1, 2, 3 ]"));
  choices.push_back(sourcemeta::core::parse_json("{ \"foo\": 1 }"));
  choices.push_back(sourcemeta::core::parse_json("{ \"bar\": 1 }"));
  const auto result = decoder.TOP_LEVEL_BYTE_CHOICE_INDEX({std::move(choices)});
  const auto expected = sourcemeta::core::parse_json("{ \"foo\": 1 }");
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, CONST_NONE_scalar) {
  InputByteStream stream{};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  const auto result = decoder.CONST_NONE({sourcemeta::core::JSON{1}});
  const sourcemeta::core::JSON expected{1};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, CONST_NONE_complex) {
  InputByteStream stream{};
  sourcemeta::jsonbinpack::Decoder decoder{stream};
  const auto result =
      decoder.CONST_NONE({sourcemeta::core::parse_json("{ \"foo\": 1 }")});
  const auto expected = sourcemeta::core::parse_json("{ \"foo\": 1 }");
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__null) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x17};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{nullptr};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__false) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x07};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{false};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__true) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x0f};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{true};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__real_3_14) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x2f, 0xf4, 0x04, 0x02};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{3.14};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__real_3_0) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x37, 0x03};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  EXPECT_TRUE(result.is_real());
  EXPECT_TRUE(result.is_integer_real());
  const sourcemeta::core::JSON expected{3.0};
  EXPECT_TRUE(expected.is_real());
  EXPECT_TRUE(expected.is_integer_real());
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__real_103_0) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x37, 0x67};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  EXPECT_TRUE(result.is_real());
  EXPECT_TRUE(result.is_integer_real());
  const sourcemeta::core::JSON expected{103.0};
  EXPECT_TRUE(expected.is_real());
  EXPECT_TRUE(expected.is_integer_real());
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__256) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x1f, 0x80, 0x02};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{256};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__minus_257) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x27, 0x80, 0x02};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{-257};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__255) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x05, 0xff};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{255};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__minus_256) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x06, 0xff};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{-256};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__0) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x0d};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{0};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__minus_1) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x0e};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{-1};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_space) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x11, 0x20};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{" "};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_foo) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x21, 0x66, 0x6f, 0x6f};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{"foo"};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_30_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0xf9, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                         0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                         0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                         0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{std::string(30, 'x')};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__shared_string_foo) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x21, 0x66, 0x6f, 0x6f, 0x20, 0x04, 0x20, 0x06};
  Decoder decoder{stream};
  const sourcemeta::core::JSON result1 =
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON result2 =
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON result3 =
      decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected1{"foo"};
  const sourcemeta::core::JSON expected2{"foo"};
  const sourcemeta::core::JSON expected3{"foo"};
  EXPECT_EQ(result1, expected1);
  EXPECT_EQ(result2, expected2);
  EXPECT_EQ(result3, expected3);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_31_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x02, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                         0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                         0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                         0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{std::string(31, 'x')};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_61_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0xf2, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                         0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                         0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                         0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                         0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                         0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
                         0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{std::string(61, 'x')};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_url) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f,
                         0x73, 0x6f, 0x75, 0x6e, 0x64, 0x63, 0x6c, 0x6f, 0x75,
                         0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x64, 0x61, 0x6e,
                         0x64, 0x79, 0x6d, 0x75, 0x73, 0x69, 0x63, 0x6e, 0x6c};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{"https://soundcloud.com/dandymusicnl"};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_128_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{
      0x3f, 0x00, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{std::string(128, 'x')};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_130_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{
      0x3f, 0x02, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{std::string(130, 'x')};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_256_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{
      0x47, 0x00, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{std::string(256, 'x')};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_258_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{
      0x47, 0x02, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{std::string(258, 'x')};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_512_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{
      0x4f, 0x00,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{std::string(512, 'x')};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_513_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{
      0x4f, 0x01,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{std::string(513, 'x')};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_1024_xs) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{
      0x57, 0x00,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78,

      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{std::string(1024, 'x')};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder,
     ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_62_xs_non_shared) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{
      0x01, 0x01, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{std::string(62, 'x')};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder,
     ANY_PACKED_TYPE_TAG_BYTE_PREFIX__string_63_xs_non_shared) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{
      0x01, 0x02, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  const sourcemeta::core::JSON expected{std::string(63, 'x')};
  EXPECT_EQ(result, expected);
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__foo_true_2000) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x24, 0x21, 0x66, 0x6f, 0x6f, 0x0f, 0x1f, 0xd0, 0x0f};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});

  EXPECT_TRUE(result.is_array());
  EXPECT_EQ(result.size(), 3);
  using namespace sourcemeta::core;
  EXPECT_EQ(result.at(0), JSON{"foo"});
  EXPECT_EQ(result.at(1), JSON{true});
  EXPECT_EQ(result.at(2), JSON{2000});
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__array_30) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0xfc, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                         0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                         0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                         0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});

  EXPECT_TRUE(result.is_array());
  EXPECT_EQ(result.size(), 30);
  using namespace sourcemeta::core;

  EXPECT_EQ(result.at(0), JSON{true});
  EXPECT_EQ(result.at(1), JSON{true});
  EXPECT_EQ(result.at(2), JSON{true});
  EXPECT_EQ(result.at(3), JSON{true});
  EXPECT_EQ(result.at(4), JSON{true});
  EXPECT_EQ(result.at(5), JSON{true});
  EXPECT_EQ(result.at(6), JSON{true});
  EXPECT_EQ(result.at(7), JSON{true});
  EXPECT_EQ(result.at(8), JSON{true});
  EXPECT_EQ(result.at(9), JSON{true});

  EXPECT_EQ(result.at(10), JSON{true});
  EXPECT_EQ(result.at(11), JSON{true});
  EXPECT_EQ(result.at(12), JSON{true});
  EXPECT_EQ(result.at(13), JSON{true});
  EXPECT_EQ(result.at(14), JSON{true});
  EXPECT_EQ(result.at(15), JSON{true});
  EXPECT_EQ(result.at(16), JSON{true});
  EXPECT_EQ(result.at(17), JSON{true});
  EXPECT_EQ(result.at(18), JSON{true});
  EXPECT_EQ(result.at(19), JSON{true});

  EXPECT_EQ(result.at(20), JSON{true});
  EXPECT_EQ(result.at(21), JSON{true});
  EXPECT_EQ(result.at(22), JSON{true});
  EXPECT_EQ(result.at(23), JSON{true});
  EXPECT_EQ(result.at(24), JSON{true});
  EXPECT_EQ(result.at(25), JSON{true});
  EXPECT_EQ(result.at(26), JSON{true});
  EXPECT_EQ(result.at(27), JSON{true});
  EXPECT_EQ(result.at(28), JSON{true});
  EXPECT_EQ(result.at(29), JSON{true});
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__array_31) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x04, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                         0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                         0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                         0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});

  EXPECT_TRUE(result.is_array());
  EXPECT_EQ(result.size(), 31);
  using namespace sourcemeta::core;

  EXPECT_EQ(result.at(0), JSON{true});
  EXPECT_EQ(result.at(1), JSON{true});
  EXPECT_EQ(result.at(2), JSON{true});
  EXPECT_EQ(result.at(3), JSON{true});
  EXPECT_EQ(result.at(4), JSON{true});
  EXPECT_EQ(result.at(5), JSON{true});
  EXPECT_EQ(result.at(6), JSON{true});
  EXPECT_EQ(result.at(7), JSON{true});
  EXPECT_EQ(result.at(8), JSON{true});
  EXPECT_EQ(result.at(9), JSON{true});

  EXPECT_EQ(result.at(10), JSON{true});
  EXPECT_EQ(result.at(11), JSON{true});
  EXPECT_EQ(result.at(12), JSON{true});
  EXPECT_EQ(result.at(13), JSON{true});
  EXPECT_EQ(result.at(14), JSON{true});
  EXPECT_EQ(result.at(15), JSON{true});
  EXPECT_EQ(result.at(16), JSON{true});
  EXPECT_EQ(result.at(17), JSON{true});
  EXPECT_EQ(result.at(18), JSON{true});
  EXPECT_EQ(result.at(19), JSON{true});

  EXPECT_EQ(result.at(20), JSON{true});
  EXPECT_EQ(result.at(21), JSON{true});
  EXPECT_EQ(result.at(22), JSON{true});
  EXPECT_EQ(result.at(23), JSON{true});
  EXPECT_EQ(result.at(24), JSON{true});
  EXPECT_EQ(result.at(25), JSON{true});
  EXPECT_EQ(result.at(26), JSON{true});
  EXPECT_EQ(result.at(27), JSON{true});
  EXPECT_EQ(result.at(28), JSON{true});
  EXPECT_EQ(result.at(29), JSON{true});

  EXPECT_EQ(result.at(30), JSON{true});
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__array_32) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x04, 0x01, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                         0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                         0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
                         0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});

  EXPECT_TRUE(result.is_array());
  EXPECT_EQ(result.size(), 32);
  using namespace sourcemeta::core;

  EXPECT_EQ(result.at(0), JSON{true});
  EXPECT_EQ(result.at(1), JSON{true});
  EXPECT_EQ(result.at(2), JSON{true});
  EXPECT_EQ(result.at(3), JSON{true});
  EXPECT_EQ(result.at(4), JSON{true});
  EXPECT_EQ(result.at(5), JSON{true});
  EXPECT_EQ(result.at(6), JSON{true});
  EXPECT_EQ(result.at(7), JSON{true});
  EXPECT_EQ(result.at(8), JSON{true});
  EXPECT_EQ(result.at(9), JSON{true});

  EXPECT_EQ(result.at(10), JSON{true});
  EXPECT_EQ(result.at(11), JSON{true});
  EXPECT_EQ(result.at(12), JSON{true});
  EXPECT_EQ(result.at(13), JSON{true});
  EXPECT_EQ(result.at(14), JSON{true});
  EXPECT_EQ(result.at(15), JSON{true});
  EXPECT_EQ(result.at(16), JSON{true});
  EXPECT_EQ(result.at(17), JSON{true});
  EXPECT_EQ(result.at(18), JSON{true});
  EXPECT_EQ(result.at(19), JSON{true});

  EXPECT_EQ(result.at(20), JSON{true});
  EXPECT_EQ(result.at(21), JSON{true});
  EXPECT_EQ(result.at(22), JSON{true});
  EXPECT_EQ(result.at(23), JSON{true});
  EXPECT_EQ(result.at(24), JSON{true});
  EXPECT_EQ(result.at(25), JSON{true});
  EXPECT_EQ(result.at(26), JSON{true});
  EXPECT_EQ(result.at(27), JSON{true});
  EXPECT_EQ(result.at(28), JSON{true});
  EXPECT_EQ(result.at(29), JSON{true});

  EXPECT_EQ(result.at(30), JSON{true});
  EXPECT_EQ(result.at(31), JSON{true});
}

TEST(JSONBinPack_Decoder,
     ANY_PACKED_TYPE_TAG_BYTE_PREFIX__object_foo_bar_baz_1) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{0x1b, 0x04, 0x66, 0x6f, 0x6f, 0x21, 0x62,
                         0x61, 0x72, 0x04, 0x62, 0x61, 0x7a, 0x15};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  EXPECT_TRUE(result.is_object());
  EXPECT_EQ(result.size(), 2);

  EXPECT_TRUE(result.defines("foo"));
  const auto &foo{result.at("foo")};
  EXPECT_TRUE(foo.is_string());
  EXPECT_EQ(foo.to_string(), "bar");

  EXPECT_TRUE(result.defines("baz"));
  const auto &baz{result.at("baz")};
  EXPECT_TRUE(baz.is_integer());
  EXPECT_EQ(baz.to_integer(), 1);
}

static auto is_member_true(const sourcemeta::core::JSON &object,
                           const std::string &key) -> bool {
  return object.defines(key) && object.at(key).is_boolean() &&
         object.at(key).to_boolean();
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__object_30_entries) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{
      0xfb, 0x03, 0x30, 0x30, 0x0f, 0x03, 0x30, 0x31, 0x0f, 0x03, 0x30,
      0x32, 0x0f, 0x03, 0x30, 0x33, 0x0f, 0x03, 0x30, 0x34, 0x0f, 0x03,
      0x30, 0x35, 0x0f, 0x03, 0x30, 0x36, 0x0f, 0x03, 0x30, 0x37, 0x0f,
      0x03, 0x30, 0x38, 0x0f, 0x03, 0x30, 0x39, 0x0f, 0x03, 0x31, 0x30,
      0x0f, 0x03, 0x31, 0x31, 0x0f, 0x03, 0x31, 0x32, 0x0f, 0x03, 0x31,
      0x33, 0x0f, 0x03, 0x31, 0x34, 0x0f, 0x03, 0x31, 0x35, 0x0f, 0x03,
      0x31, 0x36, 0x0f, 0x03, 0x31, 0x37, 0x0f, 0x03, 0x31, 0x38, 0x0f,
      0x03, 0x31, 0x39, 0x0f, 0x03, 0x32, 0x30, 0x0f, 0x03, 0x32, 0x31,
      0x0f, 0x03, 0x32, 0x32, 0x0f, 0x03, 0x32, 0x33, 0x0f, 0x03, 0x32,
      0x34, 0x0f, 0x03, 0x32, 0x35, 0x0f, 0x03, 0x32, 0x36, 0x0f, 0x03,
      0x32, 0x37, 0x0f, 0x03, 0x32, 0x38, 0x0f, 0x03, 0x32, 0x39, 0x0f};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  EXPECT_TRUE(result.is_object());
  EXPECT_EQ(result.size(), 30);

  EXPECT_TRUE(is_member_true(result, "00"));
  EXPECT_TRUE(is_member_true(result, "01"));
  EXPECT_TRUE(is_member_true(result, "02"));
  EXPECT_TRUE(is_member_true(result, "03"));
  EXPECT_TRUE(is_member_true(result, "04"));
  EXPECT_TRUE(is_member_true(result, "05"));
  EXPECT_TRUE(is_member_true(result, "06"));
  EXPECT_TRUE(is_member_true(result, "07"));
  EXPECT_TRUE(is_member_true(result, "08"));
  EXPECT_TRUE(is_member_true(result, "09"));

  EXPECT_TRUE(is_member_true(result, "10"));
  EXPECT_TRUE(is_member_true(result, "11"));
  EXPECT_TRUE(is_member_true(result, "12"));
  EXPECT_TRUE(is_member_true(result, "13"));
  EXPECT_TRUE(is_member_true(result, "14"));
  EXPECT_TRUE(is_member_true(result, "15"));
  EXPECT_TRUE(is_member_true(result, "16"));
  EXPECT_TRUE(is_member_true(result, "17"));
  EXPECT_TRUE(is_member_true(result, "18"));
  EXPECT_TRUE(is_member_true(result, "19"));

  EXPECT_TRUE(is_member_true(result, "20"));
  EXPECT_TRUE(is_member_true(result, "21"));
  EXPECT_TRUE(is_member_true(result, "22"));
  EXPECT_TRUE(is_member_true(result, "23"));
  EXPECT_TRUE(is_member_true(result, "24"));
  EXPECT_TRUE(is_member_true(result, "25"));
  EXPECT_TRUE(is_member_true(result, "26"));
  EXPECT_TRUE(is_member_true(result, "27"));
  EXPECT_TRUE(is_member_true(result, "28"));
  EXPECT_TRUE(is_member_true(result, "29"));
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__object_31_entries) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{
      0x03, 0x00, 0x03, 0x30, 0x30, 0x0f, 0x03, 0x30, 0x31, 0x0f, 0x03, 0x30,
      0x32, 0x0f, 0x03, 0x30, 0x33, 0x0f, 0x03, 0x30, 0x34, 0x0f, 0x03, 0x30,
      0x35, 0x0f, 0x03, 0x30, 0x36, 0x0f, 0x03, 0x30, 0x37, 0x0f, 0x03, 0x30,
      0x38, 0x0f, 0x03, 0x30, 0x39, 0x0f, 0x03, 0x31, 0x30, 0x0f, 0x03, 0x31,
      0x31, 0x0f, 0x03, 0x31, 0x32, 0x0f, 0x03, 0x31, 0x33, 0x0f, 0x03, 0x31,
      0x34, 0x0f, 0x03, 0x31, 0x35, 0x0f, 0x03, 0x31, 0x36, 0x0f, 0x03, 0x31,
      0x37, 0x0f, 0x03, 0x31, 0x38, 0x0f, 0x03, 0x31, 0x39, 0x0f, 0x03, 0x32,
      0x30, 0x0f, 0x03, 0x32, 0x31, 0x0f, 0x03, 0x32, 0x32, 0x0f, 0x03, 0x32,
      0x33, 0x0f, 0x03, 0x32, 0x34, 0x0f, 0x03, 0x32, 0x35, 0x0f, 0x03, 0x32,
      0x36, 0x0f, 0x03, 0x32, 0x37, 0x0f, 0x03, 0x32, 0x38, 0x0f, 0x03, 0x32,
      0x39, 0x0f, 0x03, 0x33, 0x30, 0x0f};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  EXPECT_TRUE(result.is_object());
  EXPECT_EQ(result.size(), 31);

  EXPECT_TRUE(is_member_true(result, "00"));
  EXPECT_TRUE(is_member_true(result, "01"));
  EXPECT_TRUE(is_member_true(result, "02"));
  EXPECT_TRUE(is_member_true(result, "03"));
  EXPECT_TRUE(is_member_true(result, "04"));
  EXPECT_TRUE(is_member_true(result, "05"));
  EXPECT_TRUE(is_member_true(result, "06"));
  EXPECT_TRUE(is_member_true(result, "07"));
  EXPECT_TRUE(is_member_true(result, "08"));
  EXPECT_TRUE(is_member_true(result, "09"));

  EXPECT_TRUE(is_member_true(result, "10"));
  EXPECT_TRUE(is_member_true(result, "11"));
  EXPECT_TRUE(is_member_true(result, "12"));
  EXPECT_TRUE(is_member_true(result, "13"));
  EXPECT_TRUE(is_member_true(result, "14"));
  EXPECT_TRUE(is_member_true(result, "15"));
  EXPECT_TRUE(is_member_true(result, "16"));
  EXPECT_TRUE(is_member_true(result, "17"));
  EXPECT_TRUE(is_member_true(result, "18"));
  EXPECT_TRUE(is_member_true(result, "19"));

  EXPECT_TRUE(is_member_true(result, "20"));
  EXPECT_TRUE(is_member_true(result, "21"));
  EXPECT_TRUE(is_member_true(result, "22"));
  EXPECT_TRUE(is_member_true(result, "23"));
  EXPECT_TRUE(is_member_true(result, "24"));
  EXPECT_TRUE(is_member_true(result, "25"));
  EXPECT_TRUE(is_member_true(result, "26"));
  EXPECT_TRUE(is_member_true(result, "27"));
  EXPECT_TRUE(is_member_true(result, "28"));
  EXPECT_TRUE(is_member_true(result, "29"));

  EXPECT_TRUE(is_member_true(result, "30"));
}

TEST(JSONBinPack_Decoder, ANY_PACKED_TYPE_TAG_BYTE_PREFIX__object_32_entries) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{
      0x03, 0x01, 0x03, 0x30, 0x30, 0x0f, 0x03, 0x30, 0x31, 0x0f, 0x03, 0x30,
      0x32, 0x0f, 0x03, 0x30, 0x33, 0x0f, 0x03, 0x30, 0x34, 0x0f, 0x03, 0x30,
      0x35, 0x0f, 0x03, 0x30, 0x36, 0x0f, 0x03, 0x30, 0x37, 0x0f, 0x03, 0x30,
      0x38, 0x0f, 0x03, 0x30, 0x39, 0x0f, 0x03, 0x31, 0x30, 0x0f, 0x03, 0x31,
      0x31, 0x0f, 0x03, 0x31, 0x32, 0x0f, 0x03, 0x31, 0x33, 0x0f, 0x03, 0x31,
      0x34, 0x0f, 0x03, 0x31, 0x35, 0x0f, 0x03, 0x31, 0x36, 0x0f, 0x03, 0x31,
      0x37, 0x0f, 0x03, 0x31, 0x38, 0x0f, 0x03, 0x31, 0x39, 0x0f, 0x03, 0x32,
      0x30, 0x0f, 0x03, 0x32, 0x31, 0x0f, 0x03, 0x32, 0x32, 0x0f, 0x03, 0x32,
      0x33, 0x0f, 0x03, 0x32, 0x34, 0x0f, 0x03, 0x32, 0x35, 0x0f, 0x03, 0x32,
      0x36, 0x0f, 0x03, 0x32, 0x37, 0x0f, 0x03, 0x32, 0x38, 0x0f, 0x03, 0x32,
      0x39, 0x0f, 0x03, 0x33, 0x30, 0x0f, 0x03, 0x33, 0x31, 0x0f};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  EXPECT_TRUE(result.is_object());
  EXPECT_EQ(result.size(), 32);

  EXPECT_TRUE(is_member_true(result, "00"));
  EXPECT_TRUE(is_member_true(result, "01"));
  EXPECT_TRUE(is_member_true(result, "02"));
  EXPECT_TRUE(is_member_true(result, "03"));
  EXPECT_TRUE(is_member_true(result, "04"));
  EXPECT_TRUE(is_member_true(result, "05"));
  EXPECT_TRUE(is_member_true(result, "06"));
  EXPECT_TRUE(is_member_true(result, "07"));
  EXPECT_TRUE(is_member_true(result, "08"));
  EXPECT_TRUE(is_member_true(result, "09"));

  EXPECT_TRUE(is_member_true(result, "10"));
  EXPECT_TRUE(is_member_true(result, "11"));
  EXPECT_TRUE(is_member_true(result, "12"));
  EXPECT_TRUE(is_member_true(result, "13"));
  EXPECT_TRUE(is_member_true(result, "14"));
  EXPECT_TRUE(is_member_true(result, "15"));
  EXPECT_TRUE(is_member_true(result, "16"));
  EXPECT_TRUE(is_member_true(result, "17"));
  EXPECT_TRUE(is_member_true(result, "18"));
  EXPECT_TRUE(is_member_true(result, "19"));

  EXPECT_TRUE(is_member_true(result, "20"));
  EXPECT_TRUE(is_member_true(result, "21"));
  EXPECT_TRUE(is_member_true(result, "22"));
  EXPECT_TRUE(is_member_true(result, "23"));
  EXPECT_TRUE(is_member_true(result, "24"));
  EXPECT_TRUE(is_member_true(result, "25"));
  EXPECT_TRUE(is_member_true(result, "26"));
  EXPECT_TRUE(is_member_true(result, "27"));
  EXPECT_TRUE(is_member_true(result, "28"));
  EXPECT_TRUE(is_member_true(result, "29"));

  EXPECT_TRUE(is_member_true(result, "30"));
  EXPECT_TRUE(is_member_true(result, "31"));
}

TEST(JSONBinPack_Decoder,
     ANY_PACKED_TYPE_TAG_BYTE_PREFIX__object_62_xs_shared) {
  using namespace sourcemeta::jsonbinpack;
  InputByteStream stream{
      0x1b, 0x04, 0x66, 0x6f, 0x6f, 0x01, 0x01, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
      0x78, 0x78, 0x78, 0x04, 0x62, 0x61, 0x72, 0x00, 0x01, 0x44};
  Decoder decoder{stream};
  const auto result = decoder.ANY_PACKED_TYPE_TAG_BYTE_PREFIX({});
  EXPECT_TRUE(result.is_object());
  EXPECT_EQ(result.size(), 2);

  EXPECT_TRUE(result.defines("foo"));
  const auto &foo{result.at("foo")};
  EXPECT_TRUE(foo.is_string());
  EXPECT_EQ(foo.to_string(), std::string(62, 'x'));

  EXPECT_TRUE(result.defines("bar"));
  const auto &baz{result.at("bar")};
  EXPECT_TRUE(baz.is_string());
  EXPECT_EQ(baz.to_string(), std::string(62, 'x'));
}
